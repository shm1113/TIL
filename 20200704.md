## response객체

클라이언트의 응답에 관련된 작업을 핸들할 수 있는 메서드를 소유하고 있는 객체

**HttpServletResponse클래스의 객체**로 클라이언트로 **데이터를 전송하기 위한** **Output스트림**을 얻어 낼 수도 있으며 **클라이언트의 쿠키 사용**이나 **redirect**와 같은 작업을 할 수 있는 클래스이다 





## 캐시(cache)없애는 법

```jsp
<%
	response.setHeader("Pragma", "no-cache");			//http 1.0
	response.setHeader("Cache-control","no-store");		//http 1.1
	response.setHeader("Expires","0");					//proxy server
/*
	데이터가 변경되었을 떄 ,이전 내용을 화면에 보여주는 이유!
	->서버에서 다시 응답하는게 아니라 캐시에 저장된 내용을 가져오기 떄문이다 !!!
*/
%>


```

## GET방식과 POST방식 

-   URL에 데이터를 노출하면(GET) 노출하지 않으면 POST
-   데이터를 httpheader에담으면 (GET) httpbody에 담으면(POST)
-   (GET)은 길이제한이 있고 (POST)는 길이제한이 없다
-   (GET)방식은 캐싱이 가능하고 (POST)방식은 **캐싱**이 불가능하다?



## 쿠키,세션,캐시(IT관련지식.md에 추가)

### 쿠키(cookie)

>   사용자의 브라우저에 저장되고,통신할 때 HTTP헤더에 포함되는 텍스트 데이터 파일 
>
>   이름,값,만료기간(지정가능),경로 정보가 있고 키와 값으로 구성되어 있다.
>
>   -   로그인 정보 같이 굳이 다시 서버에 요청하기에는 비효율적인 정보를 로컬에 저장해둠으로서 생산성을 높이는 것이 목적이다
>   -   로그인 정보등 사용자의 정보가 저장되는 경우가 많아 보안 문제를 잘 살펴야한다
>   -   다시 서버에 reqeuest할 필요가 없어서 속도가 빠르다
>   -   쿠키는 보안이 되지 않기 때문에 절대로 중요한 데이터가 입력되어선 안된다 
>   -   사용 예: 자동 로그인 유지.오늘그만보기 팝업창, 쇼핑몰 장바구니 

### 세션(session)

>   서버에 저장되는 쿠키 클라이언트와 서버의 통신상태,주로 중요한 데이터를 저장 시 사용한다
>
>   클라이언트가 서버에 접속시 세션id를 방급하고 서버에서는 클라이언트로 발급해준 세션id를 쿠키를 이요해서 저장한다, 그래서 연관이 있다고 한 것이다.
>
>   -   쿠키와 같이 임시로 정보를 저장해둠으로서 생산성을 높이는 것이 목적
>   -   서버에 저장해두기 떄문에 쿠키보다 보안이 우수하다
>   -   서버에 저장되어 있어서 쿠키보다 다소 느리고 유저정보가 많으면 메모리 과부하가 생길 수 있다
>   -   서버에서 관리하기 떄문에 로그관리에 용이하다
>   -   사용 예: 로그인 한 정보들

### 쿠키와 세션

>   공통점 : 데이터를 임시로 계속 저장해두는 역할
>
>   차이점: 쿠키는 사용자에게 저장되고 세션은 서버에 저장됨
>
>   쿠키와 세션은 밀접한 관계가 있는데 서버에서 사용자 하나하나를 인식할 수 없으므로 사용자가 웹에 접속했을떄 때 서버는 세션을 하나 생성하고 세션에 해당하는 쿠키를 사용자에게 생성하게 되고 이 쿠키는 사용자가 웹페에지에 접속할 때마다 서버에 보내져서 쿠키의 값을 가지고 해당하는 세션이 있는지 검사한 뒤 있을 경우 해당 세션을 사용한다 

### 캐시

>   리소스 파일들의 임시 저장소 같은 웹페이지에 접속할 때 사용자의 pc에서 로드하므로 서버를 거치지 않아도 된다 
>
>   -   이미지 같은 재사용될 것 같거나 용량이 큰 리소스를 임시로 저장해두어서 렌더링 속도를 높이는 것이 목적
>   -   쿠키와 비슷하지만 목적성에 차이가 있다
>   -   홈페이지를 접속하면 css,js,이미지 파일이 사용자의 브라우저에 저장되고 다시 같은 홈페이지를 접속하면 css,js이미지파일을 서버가 아닌 사용자의 pc에서 가져오게 된다 
>   -   **문제점 :** 홈페이지 관리자가 이미지를 변경해도 사용자는 이미지가 변경되지 않는 문제가 생긴다
>       -   **해결법 :** 사용자 브라우저의 캐시를 지워주거나, 서버에서 클라이언트로 응답을 보낼 때 header에 캐시 만료시간을 명시해주는 등 방법은 다양하다

## 서블릿 맵핑

>   -   접속 경로가 너무 긴 경우 짧은 이름으로 사용할 수 있게 해준다 
>
>   -   보안에 노출되어 있는 경로를 다른 이름으로 간단하게 맵핑할 수 있다 
>
>   -    어노테이션을 이용하는방법과 , web.xml을 이용한 방법이 있다 
>
>   -   @어노테이션 방법
>
>       -   어노테이션 : JVM이 해당 메소드의 역활을 빠르게 파악할 수 있도록 도와준다
>
>       -   ```java
>           @WebServlet("/경로명") //어노테이션을 이용한 uri 맵핑 방식
>           public class hellowordld extends HttpServlet{ // 서블릿은 HttpServlet을 상속해서 구현된다
>           	private static final long serialVersionUID= 1L;  //??
>           }
>           ```
>
>   -   web.xml방법
>
>       -   ```xml
>           <servlet>
>                <servlet-name>hello</servlet-name>		<!--서블릿 이름을 지정한다 -->
>           	<servlet-class>com.java.controller</servlet-class>	<!--서블릿 파일의 패키지,클래스이름 경로를 지정-->
>           </servlet>
>           <servlet-mapping>
>           	<servlet-name>hello</servlet-name>	<!-- 매핑시킬 서블릿을 선택한다(<servlet>으로 정의한)-->
>                <url-pattern>/hello</url-pattern><!--매핑할 url값을 지정한다 ('/'을 넣어야 url상으로 표현가능!!)-->
>           </servlet-mapping>
>           ```



## 서블릿 메소드

#### **`Init()`**메소드

>   서블릿 일생 중 한번만 호출된다 
>
>   service()메소드 이전에 실행되어야 한다
>
>   클라이언트의 요청을 처리하기전에 서블릿을 초기화할 목적으로 사용된다( 데이터베이스에 대한 접속, 다른 객체에 서블릿을 등록하는 등)

#### `Service()`메소드

>   클라이언트의 HTTP메소드 (GET,POST등)를 참조하여 doGet()/doPost() 혹은 다른 메소드를 호출할지 판단한다
>
>   재정의는 하지 않으며 doGet()/doPost()를 재정의하여 **HttpServlet의 service()**가 이를 실행하도록 한다 
>
>   Service메소드는 GenericServlet클레스에 정의되어있고 , HttpServlet클래스는 GenericServlet클래스를 상속한다
>
>   service메소드는 doGET 또는 doPost를 실행하도록 정의되어있는데 만약 **요청 방식(GET/POST)를 알 수 없다면 doGet을 호출한다**

#### `destroy()`메소드

>   init()메소드와 마찬가지로 한 번만 호출된다
>
>   웹 어플리케이션의 실행이 멈출 때 서블릿이 사용한 자원을 초기화시킬 수 있도록 이 메소드를 호출한다 



#### :book: 서블릿 컨테이너는 클라이언트의 요청(request)을 받아주고 응답(Response)할 수 있게, **웹 서버와 소켓을 만들어 통신한다** 대표적인 예로 톰캣(tomcat)이 있다. 

